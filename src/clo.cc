/*
 * This file was automaticly generated by clo++ version 0.6.0 (REL-0_6_0)
 * http://pmade.org/pjones/software/clo++/
 */

/** @file
 * This file contains the implementation of the parser class.
 * You can control the name of this source file using the
 * cxx_source_file variable.
**/

#include "clo.h"
#include <cstring>
#include <cstdlib>
#include <cctype>

namespace {
    const char const_usage[] =
"  --pT, --treeprofile string   Tree profile prefix output file\n"
"  --pg, --treeprofileflag int  Tree profile output file format convination:\n"
"                               1- Edge label. 2- Number of substrings. 4-\n"
"                               Group substrings. 8- Show symbol. 16- List\n"
"                               substrings.\n"
"  -G, --graph string           Supermaximal relation graph output file\n"
"  -M, --supmax string          Supermaximals output file\n"
"  -S, --stats string           Statics output file\n"
"  -T, --tree string            Tree output file\n"
"  -c, --coverage int           Coverage level\n"
"  -d, --debug int              Debug level\n"
"  -f, --fullstat bool          Print full statics information\n"
"  -g, --treeflag int           Tree output file format convination: 1- Edge\n"
"                               label. 2- Number of substrings. 4- Group\n"
"                               substrings. 8- Show symbol. 16- List\n"
"                               substrings.\n"
"  -i, --input string           Input file with the sequences (default:\n"
"                               standard input)\n"
"  -t, --format string          Input file type (default: raw)\n";

    const char const_help_comment[] =
"use the -h option for help";

    const char* expand_long_name (const std::string &name);
}

//#########################################################################
clo::parser::parser (void)
    : state_(state_option)
{
    std::memset(&locations_, 0, sizeof(locations_));
}
//#########################################################################
void clo::parser::parse (int argc, char *argv[], bool call_finalize) {
    for (int i=1; i<argc; ++i) parse_element(argv[i], i, source_cl);
    if (call_finalize) finalize();
}
//#########################################################################
void clo::parser::finalize (void) {
    if (state_ == state_value) {
	switch (openum_) {
	    case option_coverage:
		throw option_error("missing value for 'coverage' option");
	    case option_debug:
		throw option_error("missing value for 'debug' option");
	    case option_format:
		throw option_error("missing value for 'format' option");
	    case option_fullstat:
		throw option_error("missing value for 'fullstat' option");
	    case option_graph:
		throw option_error("missing value for 'graph' option");
	    case option_input:
		throw option_error("missing value for 'input' option");
	    case option_statics:
		throw option_error("missing value for 'stats' option");
	    case option_supermaximals:
		throw option_error("missing value for 'supmax' option");
	    case option_tree:
		throw option_error("missing value for 'tree' option");
	    case option_treeflag:
		throw option_error("missing value for 'treeflag' option");
	    case option_treeprofile:
		throw option_error("missing value for 'treeprofile' option");
	    case option_treeprofileflag:
		throw option_error("missing value for 'treeprofileflag' option");
	}

    }

}
//#########################################################################
void clo::parser::parse_element (const char *element, int position, opsource source) {
    std::size_t length = std::strlen(element);

    switch (state_) {
	case state_consume:
	    non_options_.push_back(element);
	    break;
	case state_option:
	    if (length >= 2 && element[0] == '-' && element[1] == '-') {
		if (length == 2) { state_ = state_consume; return; }
		element += 2;
		const char *value = element;
		while (*value != 0 && *value != '=') ++value;
		if (*value == '=') {
		    std::string selement(element, value - element), svalue(++value);

		    parse_long_option(selement.c_str(), position, source);
		    if (state_ != state_value) {
			std::string error("the '"); error += element; error += "' option does not take a value";
			throw option_error(error);
		    }

		    parse_value(svalue.c_str());
		    state_ = state_option;
		} else {
		    parse_long_option(element, position, source);
		}
	    } else if (length >= 2 && element[0] == '-') {
		++element;

		if (length > 2) {
		    while (*element != 0) {
			parse_short_option(*element, position, source);
			++element;
	    
			if (state_ == state_value && *element != 0) {
			    parse_value(element);
			    state_ = state_option;
			    break;
			}
		    }
		} else {
		    parse_short_option(*element, position, source);
		}
	    } else {
		non_options_.push_back(element);
	    }
	    break;
	case state_value:
	    parse_value(element);
	    state_ = state_option;
	    break;
    }
}
//#########################################################################
void clo::parser::parse_short_option (char option, int position, opsource source) {
switch (option) {
	case 'G':
    	    openum_ = option_graph;
	    state_ = state_value;
	    locations_.graph = position;
    	    return;
	case 'M':
    	    openum_ = option_supermaximals;
	    state_ = state_value;
	    locations_.supermaximals = position;
    	    return;
	case 'S':
    	    openum_ = option_statics;
	    state_ = state_value;
	    locations_.statics = position;
    	    return;
	case 'T':
    	    openum_ = option_tree;
	    state_ = state_value;
	    locations_.tree = position;
    	    return;
	case 'c':
    	    openum_ = option_coverage;
	    state_ = state_value;
	    locations_.coverage = position;
    	    return;
	case 'd':
    	    openum_ = option_debug;
	    state_ = state_value;
	    locations_.debug = position;
    	    return;
	case 'f':
    	    openum_ = option_fullstat;
	    state_ = state_value;
	    locations_.fullstat = position;
    	    return;
	case 'g':
    	    openum_ = option_treeflag;
	    state_ = state_value;
	    locations_.treeflag = position;
    	    return;
	case 'i':
    	    openum_ = option_input;
	    state_ = state_value;
	    locations_.input = position;
    	    return;
	case 't':
    	    openum_ = option_format;
	    state_ = state_value;
	    locations_.format = position;
    	    return;
	case 'h':
    	    if (source != source_cl) break;
    	    throw autoexcept(autothrow_help, const_usage);
	case '?':
    	    if (source != source_cl) break;
    	    throw autoexcept(autothrow_help, const_usage);
}

    std::string error("unknown option: '"); error += option; error += "'";
    throw option_error(error);
}
//#########################################################################
void clo::parser::parse_long_option (const char *option, int position, opsource source) {
    option = expand_long_name(option);

if (std::strcmp(option, "coverage") == 0) {
		openum_ = option_coverage;
		locations_.coverage = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "debug") == 0) {
		openum_ = option_debug;
		locations_.debug = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "format") == 0) {
		openum_ = option_format;
		locations_.format = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "fullstat") == 0) {
		openum_ = option_fullstat;
		locations_.fullstat = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "graph") == 0) {
		openum_ = option_graph;
		locations_.graph = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "input") == 0) {
		openum_ = option_input;
		locations_.input = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "pT") == 0) {
		openum_ = option_treeprofile;
		locations_.treeprofile = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "pg") == 0) {
		openum_ = option_treeprofileflag;
		locations_.treeprofileflag = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "stats") == 0) {
		openum_ = option_statics;
		locations_.statics = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "supmax") == 0) {
		openum_ = option_supermaximals;
		locations_.supermaximals = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "tree") == 0) {
		openum_ = option_tree;
		locations_.tree = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "treeflag") == 0) {
		openum_ = option_treeflag;
		locations_.treeflag = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "treeprofile") == 0) {
		openum_ = option_treeprofile;
		locations_.treeprofile = position;
state_ = state_value;
return;
} else if (std::strcmp(option, "treeprofileflag") == 0) {
		openum_ = option_treeprofileflag;
		locations_.treeprofileflag = position;
state_ = state_value;
return;
} else if (source == source_cl && std::strcmp(option, "help") == 0) {
		throw autoexcept(autothrow_help, const_usage);
}

    std::string error("unknown option '"); error += option; error += "'";
    throw option_error(error);
}
//#########################################################################
void clo::parser::parse_value (const char *value) {
switch (openum_) {
	case option_coverage:
	    {
    		char *endptr; int tmp = std::strtol(value, &endptr, 0);
		while (*endptr != 0 && std::isspace(*endptr)) ++endptr;

    		if (*endptr != 0) {
    		    std::string error("invalid integer value '"); error += value; error += "'";
    		    throw option_error(error);
    		}
		options_.coverage = tmp;
	    }
	    break;
	case option_debug:
	    {
    		char *endptr; int tmp = std::strtol(value, &endptr, 0);
		while (*endptr != 0 && std::isspace(*endptr)) ++endptr;

    		if (*endptr != 0) {
    		    std::string error("invalid integer value '"); error += value; error += "'";
    		    throw option_error(error);
    		}
		options_.debug = tmp;
	    }
	    break;
	case option_format:
	    {
		options_.format = value;
	    }
	    break;
	case option_fullstat:
	    {
    		bool bvalue;

		if (std::strcmp(value, "true") == 0) {
    		    bvalue = true;
		} else if (std::strcmp(value, "yes") == 0) {
    		    bvalue = true;
		} else if (std::strcmp(value, "false") == 0) {
    		    bvalue = false;
		} else if (std::strcmp(value, "no") == 0) {
    		    bvalue = false;
		} else {
    		    std::string error("invalid boolean value '"); error += value; error += "'";
    		    throw option_error(error);
    		}
    
		options_.fullstat = bvalue;
	    }
	    break;
	case option_graph:
	    {
		options_.graph = value;
	    }
	    break;
	case option_input:
	    {
		options_.input = value;
	    }
	    break;
	case option_statics:
	    {
		options_.statics = value;
	    }
	    break;
	case option_supermaximals:
	    {
		options_.supermaximals = value;
	    }
	    break;
	case option_tree:
	    {
		options_.tree = value;
	    }
	    break;
	case option_treeflag:
	    {
    		char *endptr; int tmp = std::strtol(value, &endptr, 0);
		while (*endptr != 0 && std::isspace(*endptr)) ++endptr;

    		if (*endptr != 0) {
    		    std::string error("invalid integer value '"); error += value; error += "'";
    		    throw option_error(error);
    		}
		options_.treeflag = tmp;
	    }
	    break;
	case option_treeprofile:
	    {
		options_.treeprofile = value;
	    }
	    break;
	case option_treeprofileflag:
	    {
    		char *endptr; int tmp = std::strtol(value, &endptr, 0);
		while (*endptr != 0 && std::isspace(*endptr)) ++endptr;

    		if (*endptr != 0) {
    		    std::string error("invalid integer value '"); error += value; error += "'";
    		    throw option_error(error);
    		}
		options_.treeprofileflag = tmp;
	    }
	    break;
}
}
//#########################################################################
const char* clo::option_error::get_help_comment (void) const {
    return const_help_comment;
}
//#########################################################################
namespace {
    const char* expand_long_name (const std::string &name) {
	std::string::size_type name_size = name.size();
	std::vector<const char*> matches;

    if (name_size <= 8 && name.compare(0, name_size, "coverage", name_size) == 0)
        	matches.push_back("coverage");

    if (name_size <= 5 && name.compare(0, name_size, "debug", name_size) == 0)
        	matches.push_back("debug");

    if (name_size <= 6 && name.compare(0, name_size, "format", name_size) == 0)
        	matches.push_back("format");

    if (name_size <= 8 && name.compare(0, name_size, "fullstat", name_size) == 0)
        	matches.push_back("fullstat");

    if (name_size <= 5 && name.compare(0, name_size, "graph", name_size) == 0)
        	matches.push_back("graph");

    if (name_size <= 5 && name.compare(0, name_size, "input", name_size) == 0)
        	matches.push_back("input");

    if (name_size <= 2 && name.compare(0, name_size, "pT", name_size) == 0)
        	matches.push_back("pT");

    if (name_size <= 2 && name.compare(0, name_size, "pg", name_size) == 0)
        	matches.push_back("pg");

    if (name_size <= 5 && name.compare(0, name_size, "stats", name_size) == 0)
        	matches.push_back("stats");

    if (name_size <= 6 && name.compare(0, name_size, "supmax", name_size) == 0)
        	matches.push_back("supmax");

    if (name_size <= 4 && name.compare(0, name_size, "tree", name_size) == 0)
        	matches.push_back("tree");

    if (name_size <= 8 && name.compare(0, name_size, "treeflag", name_size) == 0)
        	matches.push_back("treeflag");

    if (name_size <= 11 && name.compare(0, name_size, "treeprofile", name_size) == 0)
        	matches.push_back("treeprofile");

    if (name_size <= 15 && name.compare(0, name_size, "treeprofileflag", name_size) == 0)
        	matches.push_back("treeprofileflag");

    if (name_size <= 4 && name.compare(0, name_size, "help", name_size) == 0)
        	matches.push_back("help");


	if (matches.empty()) {
	    std::string error("unknown option '"); error += name; error += "'";
	    throw clo::option_error(error);
	}

	if (matches.size() == 1) {
	    return matches[0];
	}

	std::string error("the option name '"); error += name; error += "' is ambiguous";
	throw clo::option_error(error);
    }
} // end anonymous namespace
